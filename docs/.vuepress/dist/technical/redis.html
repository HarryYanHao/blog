<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 深度历险 | Harry&#39;s Blog</title>
    <meta name="description" content="生活，成长">
    
    
    <link rel="preload" href="/assets/css/0.styles.903a613d.css" as="style"><link rel="preload" href="/assets/js/app.b88cf943.js" as="script"><link rel="preload" href="/assets/js/2.70ce101a.js" as="script"><link rel="preload" href="/assets/js/21.2de00f9c.js" as="script"><link rel="prefetch" href="/assets/js/10.6e147cbe.js"><link rel="prefetch" href="/assets/js/11.9d519b98.js"><link rel="prefetch" href="/assets/js/12.8ae1faf9.js"><link rel="prefetch" href="/assets/js/13.4a7f650b.js"><link rel="prefetch" href="/assets/js/14.b9824abb.js"><link rel="prefetch" href="/assets/js/15.cce600e4.js"><link rel="prefetch" href="/assets/js/16.d6c9be22.js"><link rel="prefetch" href="/assets/js/17.5e03de55.js"><link rel="prefetch" href="/assets/js/18.f0eb0574.js"><link rel="prefetch" href="/assets/js/19.a81cfd55.js"><link rel="prefetch" href="/assets/js/20.9fb79ef1.js"><link rel="prefetch" href="/assets/js/22.25258ba7.js"><link rel="prefetch" href="/assets/js/23.e97f153c.js"><link rel="prefetch" href="/assets/js/3.09c1c532.js"><link rel="prefetch" href="/assets/js/4.8e23c845.js"><link rel="prefetch" href="/assets/js/5.4416394e.js"><link rel="prefetch" href="/assets/js/6.b72ecaf6.js"><link rel="prefetch" href="/assets/js/7.2cc40af8.js"><link rel="prefetch" href="/assets/js/8.61a7dd8d.js"><link rel="prefetch" href="/assets/js/9.307a2b00.js">
    <link rel="stylesheet" href="/assets/css/0.styles.903a613d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container common"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Harry's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/technical/" class="nav-link router-link-active">技术文档</a></div><div class="nav-item"><a href="/article/" class="nav-link">随笔</a></div><div class="nav-item"><a href="http://www.harry5.xyz/index/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  展示
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com//HarryYanHao" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/technical/" class="nav-link router-link-active">技术文档</a></div><div class="nav-item"><a href="/article/" class="nav-link">随笔</a></div><div class="nav-item"><a href="http://www.harry5.xyz/index/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  展示
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com//HarryYanHao" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Redis 深度历险</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/technical/redis.html#redis-安装" class="sidebar-link">Redis 安装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/technical/redis.html#redis-基础数据结构" class="sidebar-link">Redis 基础数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technical/redis.html#string" class="sidebar-link">string</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#list" class="sidebar-link">list</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#hash" class="sidebar-link">hash</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#set" class="sidebar-link">set</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#zset" class="sidebar-link">zset</a></li></ul></li><li><a href="/technical/redis.html#容器型数据结构通用规则" class="sidebar-link">容器型数据结构通用规则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/technical/redis.html#过期时间" class="sidebar-link">过期时间</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/technical/redis.html#分布式锁" class="sidebar-link">分布式锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technical/redis.html#超时问题" class="sidebar-link">超时问题</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#可重入性" class="sidebar-link">可重入性</a></li></ul></li><li><a href="/technical/redis.html#延时队列" class="sidebar-link">延时队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technical/redis.html#队列空了怎么办" class="sidebar-link">队列空了怎么办</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#队列延迟" class="sidebar-link">队列延迟</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#空闲连接自动断开" class="sidebar-link">空闲连接自动断开</a></li></ul></li><li><a href="/technical/redis.html#位图" class="sidebar-link">位图</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technical/redis.html#基本使用" class="sidebar-link">基本使用</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#统计和查找" class="sidebar-link">统计和查找</a></li></ul></li><li><a href="/technical/redis.html#hyperloglog" class="sidebar-link">HyperLogLog</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technical/redis.html#使用方法" class="sidebar-link">使用方法</a></li><li class="sidebar-sub-header"><a href="/technical/redis.html#注意事项" class="sidebar-link">注意事项</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis-深度历险"><a href="#redis-深度历险" aria-hidden="true" class="header-anchor">#</a> Redis 深度历险</h1> <p></p><div class="table-of-contents"><ul><li><a href="#redis-安装">Redis 安装</a></li><li><a href="#redis-基础数据结构">Redis 基础数据结构</a><ul><li><a href="#string">string</a></li><li><a href="#list">list</a></li><li><a href="#hash">hash</a></li><li><a href="#set">set</a></li><li><a href="#zset">zset</a></li></ul></li><li><a href="#容器型数据结构通用规则">容器型数据结构通用规则</a></li><li><a href="#过期时间">过期时间</a></li><li><a href="#分布式锁">分布式锁</a><ul><li><a href="#超时问题">超时问题</a></li><li><a href="#可重入性">可重入性</a></li></ul></li><li><a href="#延时队列">延时队列</a><ul><li><a href="#队列空了怎么办">队列空了怎么办</a></li><li><a href="#队列延迟">队列延迟</a></li><li><a href="#空闲连接自动断开">空闲连接自动断开</a></li></ul></li><li><a href="#位图">位图</a><ul><li><a href="#基本使用">基本使用</a></li><li><a href="#统计和查找">统计和查找</a></li></ul></li><li><a href="#hyperloglog">HyperLogLog</a><ul><li><a href="#使用方法">使用方法</a></li><li><a href="#注意事项">注意事项</a></li></ul></li></ul></div><p></p> <h2 id="redis-安装"><a href="#redis-安装" aria-hidden="true" class="header-anchor">#</a> Redis 安装</h2> <div class="tip custom-block"><p>个人使用的是docker安装,安装方式简单</p></div> <div class="language-sh extra-class"><pre class="language-sh"><code>docker pull redis
docker run --name myredis -d -p 6399:6379 redis
docker <span class="token function">exec</span> -it myredis /bin/bash
redis-cli
</code></pre></div><h2 id="redis-基础数据结构"><a href="#redis-基础数据结构" aria-hidden="true" class="header-anchor">#</a> Redis 基础数据结构</h2> <p>Redis有5种基础数据结构，分别为：String（字符串），hash（哈希），list（列表），set（集合），zset（有序集合）<br>
Redis所有的数据结构都是以唯一的key字段作为名称，然后通过这个唯一key值获取相应的value数据。
对同一个key存储不同的数据结构，redis会报<code>WRONGTYPE Operation against a key holding the wrong kind of value</code>错误信息</p> <h3 id="string"><a href="#string" aria-hidden="true" class="header-anchor">#</a> string</h3> <p>字符串String是Redis最简单的数据结构。字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用JSON序列化成字符串，然后将序列化后的字符串塞进Redis缓存。同样，获取用户信息会经过一次反序列化的过程。</p> <div class="warning custom-block"><p>字符串最大长度为512M</p></div> <p>Redis的字符串是动态字符串，是可以修改的字符串,采用与分配冗余空间的方式来减少内存的频繁分配。capacity一般高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，超过1M时只会多扩1M的空间</p> <h3 id="list"><a href="#list" aria-hidden="true" class="header-anchor">#</a> list</h3> <p>Redis的list数据结构是一种链表的结构，这意味着list的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢时间复杂度O(n) 当列表弹出最后一个元素，该数据结构自动被删除，内存被回收。<br>
慢操作<br>
lget lrange ltrim 都是复杂度O(n)操作<br>
双向指针可以实现类似 队列 栈 的数据结构操作</p> <h3 id="hash"><a href="#hash" aria-hidden="true" class="header-anchor">#</a> hash</h3> <p>hash结构是采用数组+链表二维结构，redis字典的值只能是字符串，Redis为了高性能不能采取堵塞rehash，所以使用的是渐进式的rehash策略，渐进式的rehash会在rehash的同时，保留新旧两个hash结构，然后在后续的定时任务中以及hash操作指令中，顺序渐进的将旧hash的值一点点的迁徙到新hash结构中，当搬迁完成了，就会使用新的hash结构取而代之<br>
当hash移除最后一个元素之后，该数据结构自动被删除，内存被回收
string和hash结构区别，hash可以根据字段单独存储，获取的时候可以部分获取。string只能存储所有序列化的数据。获取的时候需要一次性全部读取。比较消耗网络流量。hash存储的消耗肯定是高于string的。需要根据使用的实际的情况选择合适的存储结构。</p> <h3 id="set"><a href="#set" aria-hidden="true" class="header-anchor">#</a> set</h3> <p>set结构内部的键值对是无序且唯一的<br>
当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。<br>
eg：集合结构可以存储中奖用户id，因为有去重功能，可以保证一个用户不能中奖两次。在我们项目中可以存储委托，成交id<br>
常用的方法有 sdd smembers sismember scard#获取长度 spop#弹出一个</p> <h3 id="zset"><a href="#zset" aria-hidden="true" class="header-anchor">#</a> zset</h3> <p>zset有序集合 一方面是一个set 保证了value的唯一性 另一方面提供了一个score字段 代表这个value的排序权重<br>
zset中最后一个元素移除之后，数据结构自动删除，内存被回收。</p> <h2 id="容器型数据结构通用规则"><a href="#容器型数据结构通用规则" aria-hidden="true" class="header-anchor">#</a> 容器型数据结构通用规则</h2> <p>list/set/zset/hash 这四种数据结构是容器型数据结构 他们共享下面两条通用规则</p> <p>1.create if not exist<br>
如果容器不存在，那就创建一个，再进行操作。比如rpush，比如刚开始是没有列表的，则会自动创建一个，然后再rpush进去新元素</p> <p>2.drop if no elements<br>
如果容器内的最后一个元素被移除，容器消失，释放内存。</p> <h2 id="过期时间"><a href="#过期时间" aria-hidden="true" class="header-anchor">#</a> 过期时间</h2> <p>Redis所有的数据结构都可以设置过期时间，时间到了，redis会自动删除相应的对象。需要注意的是过期是以对象为单位即是以key为单位 不是以其中的子key。<br>
还有一点需要注意，如果你为某个key设置了过期时间，但是有用set修改了值，过期时间会消失。</p> <h2 id="分布式锁"><a href="#分布式锁" aria-hidden="true" class="header-anchor">#</a> 分布式锁</h2> <p>分布式锁本质上要实现的目标就是在redis里面占位，当别的进程要来占时，发现已经有key值，只能放弃或者等待。<br>
占位一般是使用setnx(set if not exists)指令，只允许被一个客户端占位，先来先占，用完了之后使用del删除key释放位置。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>setnx lock:codehole <span class="token boolean">true</span>
<span class="token keyword">do</span> something
del lock:codehole
</code></pre></div><p>但是有个问题，如果执行逻辑中间出现了异常，可能导致del指令没有被调用，从而造成死锁，锁永远得不到释放。于是我们在拿到锁之后，再给锁加上一个过期时间，比如5s，这样即使中间出现异常也可以保证5s后锁会自动释放。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>setnx lock:codehole <span class="token boolean">true</span>
expire lock:codehole 5
<span class="token keyword">do</span> something
del lock:codehole
</code></pre></div><p>但是以上逻辑还是有问题，如果setnx和expire之间不是原子指令。如果这两条指令可以一起执行就不会出现问题，并且这个问题无法使用redis事务的特性来解决 因为expire需要依赖于setnx的执行结果。如果setnx没有抢到锁，expire是不应被执行的。事务里没有if-else分支逻辑，事务的特点是一口气执行，要么一个都不执行。redis2.8版本后作者加入了set指令的扩展参数，使得setnx和expire指令可以一起执行，解决了分布式锁的乱象。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token keyword">set</span> lock:codehole <span class="token boolean">true</span> ex 5 nx OK
<span class="token keyword">do</span> something
del lock:codehole
</code></pre></div><h3 id="超时问题"><a href="#超时问题" aria-hidden="true" class="header-anchor">#</a> 超时问题</h3> <p>redis的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程执行完成之间拿到了锁。<br>
为了避免这个问题，Redis分布式锁不能用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。<br>
有一个更加安全的方案是set指令的value参数设置为一个随机数，释放时先匹配随机数是否一致，然后再删除key。但是匹配value和删除key不是一个原子操作，需要用Lua脚本来处理，Lua脚本可以保证连续多个指令的原子性执行。</p> <h3 id="可重入性"><a href="#可重入性" aria-hidden="true" class="header-anchor">#</a> 可重入性</h3> <p>这里只解释概念，不推荐使用。可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程多次加锁，那么这个锁就是可重入的。</p> <h2 id="延时队列"><a href="#延时队列" aria-hidden="true" class="header-anchor">#</a> 延时队列</h2> <p>Redis的消息队列没有像Kafka和Rabbitmq那样多的高级特性，也没有ack保证，如果对消息的可靠性有着极致的追求，那么它就不适用。<br>
Redis的list（列表）数据结构常用来作为异步消息队列使用，使用rpush/lpush操作入队列，使用lpop和rpop来出队列。</p> <h3 id="队列空了怎么办"><a href="#队列空了怎么办" aria-hidden="true" class="header-anchor">#</a> 队列空了怎么办</h3> <p>客户端通过队列的pop操作来获取消息，然后进行处理，处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。<br>
可是如果队列空了，客户端就会陷入pop的死循环，不停地pop，没有数据，接着pop，有没有数据，浪费生命的空轮询。空轮询不但拉高了客户端的CPU，redis的QPS也会被拉高。<br>
通常我们使用sleep来解决这个问题，让线程睡一会，sleep(1) 不但客户端的CPU能降下来，Redis的QPS也降下来了。</p> <h3 id="队列延迟"><a href="#队列延迟" aria-hidden="true" class="header-anchor">#</a> 队列延迟</h3> <p>用上面睡眠的方法可以解决问题，但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有一个消费者，那么这个延迟就是1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡眠时间是岔开的。
可以缩小延迟时间来降低延迟，也可以用<code>blpop/brpop</code>来解决，前缀字符b的意思是blocking 也就是阻塞读。<br>
阻塞读再队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立即醒过来。消息的延迟几乎为零，用<code>blpop/brpop</code>代替<code>lpop/rpop</code>就完美的解决了上述问题。</p> <h3 id="空闲连接自动断开"><a href="#空闲连接自动断开" aria-hidden="true" class="header-anchor">#</a> 空闲连接自动断开</h3> <p>如果线程一直阻塞在那里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候<code>blpop/brpop</code>会抛出异常。
所以编写客户端消费者的时候要小心，注意捕获异常，并且重试。</p> <h2 id="位图"><a href="#位图" aria-hidden="true" class="header-anchor">#</a> 位图</h2> <p>在平时开发过程中，会有一些bool型的数据需要存储，比如用户一年的签到记录，签了为1，没签为0 要记录365天，如果使用普通key/value 再同时考虑用户数量，这个存储空间是惊人的。<br>
为了解决这个问题,Redis 提供了位图数据结构，这样每天的签到记录只占据一个位,365天就是365位，46个字节 （8bit=1Byte 1kb=1024B）  这样就大大的节约了储存空间。<br>
位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是byte数组。我们可以使用普通的 <code>get/set</code>直接获取和设置整个位图的内容，也可以使用位图操作<code>getbit/setbit</code>等将byte数组看成是’位数组‘来处理。</p> <h3 id="基本使用"><a href="#基本使用" aria-hidden="true" class="header-anchor">#</a> 基本使用</h3> <p>Redis的位数组是自动扩展的，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。基本使用有零存零取，零存整取，整存零取。零存就是使用<code>setbit</code>，零取使用<code>getbit</code>，整取使用<code>get</code>，如果对应位的字节是不可打印的字符，redis-cli会显示该字符的16进制形式。</p> <h3 id="统计和查找"><a href="#统计和查找" aria-hidden="true" class="header-anchor">#</a> 统计和查找</h3> <p>Redis 提供了位图的统计指令 bitcount和位图的查找指令bitpos，bitcount用来统计指定位置范围内1的个数，bitpos用来查找指定范围内出现的第一个0或1。如果制定了范围参数[start,end]就可以统计在某个时间范围内用户签到了多少天，遗憾的是start和end参数是字节索引，也就是说指定的范围必须是8的倍数，而不能任意指定。</p> <h2 id="hyperloglog"><a href="#hyperloglog" aria-hidden="true" class="header-anchor">#</a> HyperLogLog</h2> <p>HyperLogLog也是redis提供的一种数据结构。这种数据结构就是用来解决统计问题，HyperLogLog提供不精确的去重技术方案，误差在0.81%，这种精度可以满足UV类的统计需求。</p> <h3 id="使用方法"><a href="#使用方法" aria-hidden="true" class="header-anchor">#</a> 使用方法</h3> <p>HyperLogLog提供了两个指令pfadd和pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数，pfadd用法和set集合的sadd是一样的，来一个用户ID,就将用户ID塞进去。pfcount和scard用法是一样的，直接获取计数量</p> <div class="language-sh extra-class"><pre class="language-sh"><code>pfadd hyperloglog user1
pfadd hyperloglog user2
pfcount hyperloglog <span class="token comment">#结果为2</span>
pfadd hyperloglog user3
pfcount hyperloglog <span class="token comment">#结果为3</span>
pfadd hyper harry
pfmerge hyperloglog hyper
pfcount hyperloglog <span class="token comment">#结果为4</span>
</code></pre></div><h3 id="注意事项"><a href="#注意事项" aria-hidden="true" class="header-anchor">#</a> 注意事项</h3> <p>除了上述的两个命令外。还提供了三个指令，pfmerge，用于将多个pf计数值累加在一起形成一个新的pf值。HyperLogLog这个数据结构是需要花费代价的，它需占据一定的12k存储空间，所以它不适合统计单个用户相关的数据。如果用户量特别庞大的时候，相比set方案，这个数据结构用于统计uv还是非常值得的。
不过也不用过于担心，Redis对HyperLogLog的储存进行了优化，在技术比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阀值时，才会一次性转变成稠密矩阵，才会占用12k的空间。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">12/23/2019, 8:23:50 PM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.b88cf943.js" defer></script><script src="/assets/js/2.70ce101a.js" defer></script><script src="/assets/js/21.2de00f9c.js" defer></script>
  </body>
</html>
